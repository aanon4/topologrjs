<!DOCTYPE html>
<html lang="en">
  <head>
    <title>AREDN-FrontRoyal Mesh Network</title>

    <script src="vis-network.min.js"></script>
    <script src="renderjson.js"></script>

    <style type="text/css">
      body,
      html {
        font: 10pt sans;
        line-height: 1.5em;
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        color: #4d4d4d;
        box-sizing: border-box;
        overflow: hidden;
      }

      #contents {
        height: 100%;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        position: relative;
      }

      #left,
      #right {
        position: absolute;
        width: 50%;
        height: 100%;
        margin: 0;
        padding: 10px;
        box-sizing: border-box;
        display: inline-block;
      }

      #left {
        width: 30%;
        height: 100%;
        top: 0;
        left: 0;
      }

      #right {
        width: 70%;
        top: 0;
        right: 0;
      }

      #error {
        color: red;
      }

      #mynetwork {
        /*width: 100%;*/
        height: 100%;
        border: 1px solid #d3d3d3;
        box-sizing: border-box;
      }

      #nodeData {
        width: 100%;
        height: auto;
        max-height: 82%;
        border: 1px solid #d3d3d3;
        box-sizing: border-box;
        overflow: auto;
      }

      #page {
        height: auto;
        width: auto;
      }

      #logo {
        margin: 0 auto;
      }

      img {
        width: 128px;
        height: 128px;
        object-fit: cover;
        float: left;
      }

      #color1 {
        width: 120px;
        height: 40px;
        margin: 15px auto;
        display: none;
      }
    </style>
  </head>

  <body>
    <div id="contents">
      <div id="left">
        <div id="logo">
          <img src="Network-icon.png" alt="AREDN-FrontRoyal" />
          <center><h2><%= meshName %></h2></center>
        </div>
        <hr />
        <div id="nodeName"></div>

        <input
          type="color"
          class="color1"
          name="color1"
          id="color1"
          value="#97C2FC"
        />

        <div id="nodeData"></div>
      </div>
      <div id="right">
        <div
          id="mynetwork"
          ondrop="dropSettings(event);"
          ondragover="dragover_handler(event)"
        ></div>
      </div>
    </div>

    <script type="text/javascript">
      var selectedNode;
      var nodeGroup = [];
      var nodecolors = {};

      //set up the  the color-picker handler
      var color1 = document.getElementById("color1");
      color1.addEventListener("input", returnColor);

      const options = {
        // TODO: Figure out how to throw this up into a side panel, Toggle on/off
        // configure: {
        //   enabled: true,
        //   filter: 'nodes', //,edges',
        //   container: undefined,
        //   showButton: true
        // },

        nodes: {
          physics: false,
        },
        edges: {
          //"selfReferenceSize": null,
          selfReference: {
            angle: 0.7853981633974483,
          },
          shadow: {
            enabled: false,
          },
          smooth: {
            forceDirection: "none",
          },
        },
      };

      //data insertion from server
      //convert codes back to characters
      meshNodes = JSON.parse("<%= meshNodes %>".replace(/\&\#34\;/g, '"'));
      meshLinks = JSON.parse("<%= meshLinks %>".replace(/\&\#34\;/g, '"'));
      meshServices = JSON.parse(
        "<%= meshServices %>".replace(/\&\#34\;/g, '"')
      );
      console.table(meshLinks);

      //get data from local storage if it exists
      nodePositions = JSON.parse(localStorage.getItem("node-positions"));
      if (nodePositions === null) {
        nodePositions = {};
      }
      nodeColors = JSON.parse(localStorage.getItem("node-colors"));
      if (nodeColors === null) {
        nodeColors = {};
      }

      var data = {};
      // create an nodes and links array
      let nodeArray = [];
      var edgeArray = [];

      //process all the topology links
      for (let i = 0; i < meshLinks.length; i++) {
        //don't process links with undefined nodes.
        if (
          meshLinks[i].hasOwnProperty("from") ||
          meshLinks[i].hasOwnProperty("to")
        ) {
          let extraOptions = {};
          //if the link cost is < 0.1 then it's a DtD node so color it red
          if (meshLinks[i].ecost < 0.1)
            extraOptions = {
              //color: "red",
              title: "DtD",
            };
          //add the edge topology data to vis
          //set the edge width inversely proportional to the cost
          edgeArray.push({
            from: meshLinks[i].from,
            to: meshLinks[i].to,
            arrows: {
              to: { enabled: true },
            },
            title: meshLinks[i].ecost,
            width: 5.0 / (meshLinks[i].ecost + 1.0),
            ...extraOptions,
          });
          // Add the nodes
          if (meshLinks[i].hasOwnProperty("from")) {
            addNode(meshLinks[i].from);
          }
          if (meshLinks[i].hasOwnProperty("to")) {
            addNode(meshLinks[i].to);
          }
        } else {
          console.log("wtf: ", meshLinks[i]);
        }
        for (nodeName in nodePositions) {
          addNode(nodeName);
        }
      }

      //initialize vis.js data structures with nodes and edges
      var nodes = new vis.DataSet(nodeArray);
      console.log(nodes);
      var edges = new vis.DataSet(edgeArray);
      var data = {
        nodes: nodes,
        edges: edges,
      };

      var container = document.getElementById("mynetwork");

      // create the network
      var network = new vis.Network(container, data, options);

      //event handlers
      network.on("doubleClick", (mydata) => {
        jump(mydata);
      });
      network.on("dragEnd", (mydata) => {
        savePos(mydata);
      });
      network.on("click", (mydata) => {
        setColor(mydata);
      });
      network.on("selectNode", async (mydata) => {
        colorNode(mydata);
        await loadNodeInfo(mydata);
      });

      document.addEventListener("keydown", function (event) {
        if (event.ctrlKey && event.key === "Enter") {
          // Ctrl+Enter
          localStorage.removeItem("node-positions");
          location.reload(true);
        } else if (event.ctrlKey && event.key === "s") {
          downloadTextFile(
            JSON.stringify({
              nodePositions,
              nodeColors,
            }),
            "settings.json"
          );
          event.preventDefault();
        }
      });

      loadServices();
      async function loadServices() {
        await removeChildren(document.getElementById("nodeData"));
        document.getElementById("nodeName").innerHTML =
          "<center><h3>Mesh Services Directory</h3></center>";
        renderjson.set_sort_objects(true);
        renderjson.set_show_to_level(1);
        let rjson = renderjson(meshServices);
        if (rjson.textContent === '""') return;
        await removeChildren(document.getElementById("nodeData"));
        document.getElementById("nodeData").appendChild(rjson);
      }

      async function removeChildren(parent) {
        if (parent !== null) {
          while (parent.childNodes.length > 0) {
            parent.childNodes[0].remove();
          }
        }
      }

      async function loadNodeInfo(mydata) {
        await removeChildren(document.getElementById("nodeData"));
        if (mydata.nodes.length > 0) {
          document.getElementById(
            "nodeName"
          ).innerHTML = `<center><h3>${mydata.nodes[0]}</h3></center>`;
          var d;
          //get the URL to open from the vis.js data
          let obj = nodeArray.find((o) => o.id === mydata.nodes[0]);
          let response = await fetch(
            "http://" + location.host + "/info/" + mydata.nodes[0]
          );
          if (response.ok) {
            // if HTTP-status is 200-299
            // get the response body (the method explained below)
            d = await response.json();
          } else {
            console.log("HTTP-Error: " + response.status);
          }

          renderjson.set_sort_objects(true);
          renderjson.set_show_to_level(1);
          let rjson = renderjson(d);
          if (rjson.textContent === '""') return;
          // let txt = `${d.node}<br>lat: ${d.lat} lon: ${d.lon}<br>grid: ${d.grid_square}<br>uptime: ${d.sysinfo.uptime}<ul><li>Services:<ol>`
          // for (let i = 0; i < d.services_local.length; i++) {
          //   txt = txt + `<li>${d.services_local[i].name}</li>`
          // }
          // txt = txt + "</ol></li></ul><ul><li>Links:<ol>"
          // for (const ip in d.link_info) {
          //   if (d.link_info[ip].linkCost > 100) continue;
          //   txt = txt + `<li>${meshNodes[ip]} - ${d.link_info[ip].linkQuality}</li>`
          // }
          // txt = txt + "</ol></li></ul>"
          //document.getElementById("nodeData").innerHTML = txt;

          await removeChildren(document.getElementById("nodeData"));
          document.getElementById("nodeData").appendChild(rjson);
        }
      }

      //doubleclick event
      function jump(mydata) {
        //console.log(mydata);
        //if an node was double clicked
        if (mydata.nodes.length > 0) {
          //get the URT to open from the vis.js data
          let obj = nodeArray.find((o) => o.id === mydata.nodes[0]);
          //open new tab with the node's homepage
          window.open(obj.URL);
        } else {
          //if the background is doubleclicked handle that here.
        }
      }

      async function setColor(mydata) {
        if (mydata.nodes.length === 0) {
          if (nodeGroup.length === 0) {
            //single click on background
            //TODO: Change Network Background Color
            //mynetwork.style.background-color = red;
          } else {
            //clar node info
            document.getElementById("nodeName").innerHTML = "";
            color1.style.display = "none";
            await removeChildren(document.getElementById("nodeData"));
            color1.style.display = "none";
            nodePositions = JSON.parse(localStorage.getItem("node-positions"));
            if (nodePositions === null) {
              nodePositions = {};
            }
            for (let i = 0; i < nodeGroup.length; i++) {
              na = nodeArray.find((n) => n.id === nodeGroup[i].id);
              na.color = color1.value;
              if (nodePositions[na.id] !== undefined) {
                na.x = nodePositions[na.id].x;
                na.y = nodePositions[na.id].y;
              }
              nodeColors[na.id] = color1.value;
            }
            localStorage.setItem("node-colors", JSON.stringify(nodeColors));
            nodeGroup = [];
            nodes = new vis.DataSet(nodeArray);
            data = {
              nodes: nodes,
              edges: edges,
            };
            network.setData(data);
          }
          await loadServices();
        }
      }

      function addNode(node) {
        let na = {};
        //is the node already in the nodeArray?
        na = nodeArray.find((n) => n.id === node);
        if (na === undefined) {
          // if the node has NOT already been added
          let n = node;
          if (n.substr(0, 1) !== "1") {
            n = n + ".local.mesh";
          }
          let extraOptions = { URL: "http://" + n };
          try {
            extraOptions = {
              ...extraOptions,
              x: nodePositions[node].x,
              y: nodePositions[node].y,
            };
          } catch (e) {}
          try {
            if (nodeColors[node] !== null) {
              extraOptions = {
                ...extraOptions,
                color: nodeColors[node],
              };
            }
          } catch (e) {}
          nodeArray.push({
            id: node,
            label: node,
            ...extraOptions,
          });
        }
      }

      function savePos(mydata) {
        nodePositions = network.getPositions();
        for (let i = 0; i < nodeArray.length; i++) {
          nodeArray[i] = {
            ...nodeArray[i],
            ...nodePositions[nodeArray[i].id],
          };
        }
        localStorage.setItem("node-positions", JSON.stringify(nodePositions));
      }

      function colorNode(mydata) {
        color1.style.display = "block";
        color1.value = "#97C2FC";
        if (nodeColors[mydata.nodes[0]] !== undefined) {
          color1.value = nodeColors[mydata.nodes[0]];
        }

        selectedNode = mydata.nodes[0];
        nodeGroup = nodeArray.filter((n) =>
          n.id.startsWith(selectedNode.substr(0, selectedNode.indexOf("-") - 1))
        );
      }

      function returnColor() {
        na = nodeArray.find((n) => n.id === selectedNode);
        na.color = color1.value;
        nodes = new vis.DataSet(nodeArray);
        data = {
          nodes: nodes,
          edges: edges,
        };
        network.setData(data);
      }

      function downloadTextFile(text, name) {
        const a = document.createElement("a");
        const type = name.split(".").pop();
        a.href = URL.createObjectURL(
          new Blob([text], { type: `text/${type === "txt" ? "plain" : type}` })
        );
        a.download = name;
        a.click();
      }

      function dropSettings(event) {
        event.preventDefault();
        const [item] = event.dataTransfer.items;
        console.log(item.getAsFile());
        var file = event.dataTransfer.files[0],
          reader = new FileReader();
        reader.onload = function (event) {
          console.log(event.target.result);
          try {
            let ds = JSON.parse(event.target.result);
            for (let i = 0; i < nodeArray.length; i++) {
              nn = nodeArray[i].id;
              try {
                nodeArray[i].x = ds.nodePositions[nn].x;
                nodeArray[i].y = ds.nodePositions[nn].y;
              } catch (e) {}
              var color;
              try {
                color = ds.nodeColors[nn];
                nodeColors[nn] = color;
              } catch (e) {}
              if (color !== undefined) {
                nodeArray[i].color = color;
              }
              console.log(nodeArray[i]);
            }
            localStorage.setItem(
              "node-positions",
              JSON.stringify(ds.nodePositions)
            );
            localStorage.setItem("node-colors", JSON.stringify(ds.nodeColors));
            nodes = new vis.DataSet(nodeArray);

            data = {
              nodes: nodes,
              edges: edges,
            };
            network.setData(data);
          } catch (e) {
            console.log(e);
          }
        };
        reader.readAsText(file);
      }

      function dragover_handler(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = "move";
      }
    </script>
  </body>
</html>
